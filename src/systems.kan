import "sdl";
import "str";
import "vec";
import "text";
import "math";
import "input" as i;
import "physics" as p;
import "graphics" as g;

import "ecs" as _;
import "components" as _;

let interaction_cooldown: i64 = 500000000;

delegate def UpdateFn(s: *System, ts: f32);

type System struct {
    relevant_components: Signature,
    // all entities relevant for this system. Has to be updated if new entities are created
    entities: vec.Vec, // vec.Vec[Entity]
    ecs: *ECS,
    update_fn: UpdateFn
}

def (s: *System) contains_entity(e: Entity): bool {
    for let i: usize = 0; i < s.entities.len; i += 1 {
        if e.eq(*(s.entities.get_ptr(i) as *Entity)) {
            return true;
        }
    }

    return false;
}

def (s: *System) update(ts: f32) {
    s.update_fn(s, ts);
}

def (s: *System) free() {
    s.entities.free();
}

type SpriteRenderSystem struct {
    s: System,
    r: *sdl.Renderer
}

def sprite_render_system(ecs: *ECS, r: *sdl.Renderer): SpriteRenderSystem {
    let sig = signature().with(ComponentKind.Transform).with(ComponentKind.Sprite);
    let sys = System {
        relevant_components: sig,
        entities: vec.create(sizeof Entity),
        ecs: ecs,
        update_fn: &sprite_render_system_update
    };

    return SpriteRenderSystem {
        s: sys,
        r: r
    };
}

def sprite_render_system_update(s: *System, ts: f32) {
    let rs = s as *SpriteRenderSystem;

    for let i: usize = 0; i < s.entities.len; i += 1 {
        let e = *(s.entities.get_ptr(i) as *Entity);
        let sprite = s.ecs.get_component(e, ComponentKind.Sprite) as *g.Sprite;
        let transform = s.ecs.get_component(e, ComponentKind.Transform) as *p.Transform;

        let src = sdl.Rect {
            x: transform.position.x as i32,
            y: transform.position.y as i32,
            w: transform.scale as i32 * 16,
            h: transform.scale as i32 * 16
        };
        g.render_sprite(rs.r, sprite, src, sdl.RendererFlip.None);
    }
}

type TextRenderSystem struct {
    s: System,
    r: *sdl.Renderer
}

def text_render_system(ecs: *ECS, r: *sdl.Renderer): TextRenderSystem {
    let sig = signature().with(ComponentKind.TextBox).with(ComponentKind.Interaction);
    let sys = System {
        relevant_components: sig,
        entities: vec.create(sizeof Entity),
        ecs: ecs,
        update_fn: &text_render_system_update
    };

    return TextRenderSystem {
        s: sys,
        r: r
    };
}

def text_render_system_update(s: *System, ts: f32) {
    let ts = s as *TextRenderSystem;

    for let i: usize = 0; i < s.entities.len; i += 1 {
        let e = *(s.entities.get_ptr(i) as *Entity);
        let text = s.ecs.get_component(e, ComponentKind.TextBox) as *TextBox;
        let interact = s.ecs.get_component(e, ComponentKind.Interaction) as *Interaction;

        if interact.current_state == 0 {
            text.chars_shown = 0;
            continue;
        }

        let content = text.dialog_text.offset(text.chars_shown);
        let chars_shown = text.textbox.render(ts.r, content, 5);

        // reset after showing everything
        if chars_shown == 0 {
            text.chars_shown = 0;
            interact.current_state = interact.last_state = 0;
            continue;
        }

        if interact.last_state != interact.current_state && interact.last_state != 0 {
            text.chars_shown += chars_shown;
        }

        interact.last_state = interact.current_state;
    }
}

type AnimationRenderSystem struct {
    s: System,
    r: *sdl.Renderer
}

def animation_render_system(ecs: *ECS, r: *sdl.Renderer): AnimationRenderSystem {
    let sig = signature().with(ComponentKind.Transform).with(ComponentKind.AnimatedGraphics);
    let sys = System {
        relevant_components: sig,
        entities: vec.create(sizeof Entity),
        ecs: ecs,
        update_fn: &animation_render_system_update
    };

    return AnimationRenderSystem {
        s: sys,
        r: r
    };
}

def animation_render_system_update(s: *System, ts: f32) {
    let rs = s as *AnimationRenderSystem;

    for let i: usize = 0; i < s.entities.len; i += 1 {
        let e = *(s.entities.get_ptr(i) as *Entity);
        let graphics = s.ecs.get_component(e, ComponentKind.AnimatedGraphics) as *g.AnimatedGraphics;
        graphics.current_animation.update(ts);

        let transform = s.ecs.get_component(e, ComponentKind.Transform) as *p.Transform;

        // update animation based on velocity
        if s.ecs.has_component(e, ComponentKind.Movement) {
            let movement = s.ecs.get_component(e, ComponentKind.Movement) as *p.Movement;
            graphics.update_based_on_movement(movement.velocity.x, movement.velocity.y);
        }

        let src = sdl.Rect {
            x: transform.position.x as i32,
            y: transform.position.y as i32,
            w: transform.scale as i32 * 16,
            h: transform.scale as i32 * 16
        };

        g.render_sprite(rs.r, graphics.current_animation.current_sprite(), src, graphics.flip);
    }
}

type DebugRenderSystem struct {
    s: System,
    renderer: *sdl.Renderer,
    debug: *bool
}

def debug_render_system(ecs: *ECS, r: *sdl.Renderer, debug: *bool): DebugRenderSystem {
    let sig = signature()
        .with(ComponentKind.Transform)
        .with(ComponentKind.Hitbox);

    let sys = System {
        relevant_components: sig,
        entities: vec.create(sizeof Entity),
        ecs: ecs,
        update_fn: &debug_render_system_update
    };

    return DebugRenderSystem {
        s: sys,
        renderer: r,
        debug: debug
    };
}

def debug_render_system_update(s: *System, ts: f32) {
    let ds = s as *DebugRenderSystem;
    if !*ds.debug {
        return;
    }

    ds.renderer.set_draw_color(255, 0, 0, 255);

    for let j: usize = 0; j < s.entities.len; j += 1 {
        let e = *(s.entities.get_ptr(j) as *Entity);
        let transform = *(s.ecs.get_component(e, ComponentKind.Transform) as *p.Transform);
        let hitbox = *(s.ecs.get_component(e, ComponentKind.Hitbox) as *p.Hitbox);

        let abs_rect = hitbox.as_absolute_rect(transform);
        ds.renderer.draw_rect(&abs_rect);

        if !s.ecs.has_component(e, ComponentKind.Interaction) {
            continue;
        }

        ds.renderer.set_draw_color(0, 255, 0, 255);
        defer ds.renderer.set_draw_color(255, 0, 0, 255);

        let interact = s.ecs.get_component(e, ComponentKind.Interaction) as *Interaction;
        let abs_rect = interact.hitbox.as_absolute_rect(transform);
        ds.renderer.draw_rect(&abs_rect);
    }
}

type MovementSystem struct {
    s: System,
    input: *i.InputState
}

def movement_system(ecs: *ECS, movement: *i.InputState): MovementSystem {
    let sig = signature()
        .with(ComponentKind.Input)
        .with(ComponentKind.Movement)
        .with(ComponentKind.Transform)
        .with(ComponentKind.Movement);

    let sys = System {
        relevant_components: sig,
        entities: vec.create(sizeof Entity),
        ecs: ecs,
        update_fn: &movement_system_update
    };

    return MovementSystem {
        s: sys,
        input: movement
    };
}

def movement_system_update(s: *System, ts: f32) {
    let is = s as *MovementSystem;
    for let j: usize = 0; j < s.entities.len; j += 1 {
        let e = *(s.entities.get_ptr(j) as *Entity);
        let transform = s.ecs.get_component(e, ComponentKind.Transform) as *p.Transform;
        let movement = s.ecs.get_component(e, ComponentKind.Movement) as *p.Movement;

        movement.velocity = math.zero_vec2f();

        let input = s.ecs.get_component(e, ComponentKind.Input) as *Input;
        if !input.interacting {
            if is.input.is_action_pressed(i.Action.Right) {
                movement.velocity.x += 1.0;
            }

            if is.input.is_action_pressed(i.Action.Left) {
                movement.velocity.x -= 1.0;
            }

            if is.input.is_action_pressed(i.Action.Down) {
                movement.velocity.y += 1.0;
            }

            if is.input.is_action_pressed(i.Action.Up) {
                movement.velocity.y -= 1.0;
            }


            movement.velocity = movement.velocity
                .normalized()
                .times(movement.speed);

            transform.update_with_vel(movement.velocity, ts);
        }

        let now = sdl.now();
        let can_interact = now - input.last_interact > interaction_cooldown;
        let trying_interact = can_interact && is.input.is_action_pressed(i.Action.Interact);

        if !s.ecs.has_component(e, ComponentKind.Hitbox) {
            continue;
        }

        let hitbox = *(s.ecs.get_component(e, ComponentKind.Hitbox) as *p.Hitbox);
        let rect = hitbox.as_absolute_rect(*transform);

        // the quadratic complexity is irrelevant due to the very small (usually 1) amout of
        // entities this system operates on
        let hitbox_sig = signature().with(ComponentKind.Transform).with(ComponentKind.Hitbox);
        let hitbox_ents = s.ecs.entities_with_components(hitbox_sig);
        for let k: usize = 0; k < hitbox_ents.len; k += 1 {
            let other = *(hitbox_ents.entities + k);
            if other.eq(e) {
                continue;
            }

            let other_hit = *(s.ecs.get_component(other, ComponentKind.Hitbox) as *p.Hitbox);
            let other_trans = *(s.ecs.get_component(other, ComponentKind.Transform) as *p.Transform);

            let other_rect = other_hit.as_absolute_rect(other_trans);
            // adjust transform so objects don't overlap
            p.resolve_collision(transform, hitbox, other_rect);

            // if the interaction button was pressed, an interaction is possible and the other
            // entity supports interaction
            if !s.ecs.has_component(other, ComponentKind.Interaction) {
                continue;
            }

            let interact = s.ecs.get_component(other, ComponentKind.Interaction) as *Interaction;
            input.interacting = interact.current_state != 0;

            if !trying_interact {
                continue;
            }

            input.last_interact = now;

            let interact_hit = interact.hitbox;
            let interact_rect = interact_hit.as_absolute_rect(other_trans);

            let h_collision = 0;
            let v_collision = 0;
            p.rect_collisions(rect, interact_rect, &h_collision, &v_collision);

            // resetting this is left to the TextRenderSystem, which is not a pretty solution,
            // but it works
            if h_collision != 0 && v_collision != 0 {
                interact.current_state += 1;
            }
        }
    }
}
