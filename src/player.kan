import "io";
import "sdl";
import "math";
import "config";
import "input" as i;
import "graphics" as g;

type Transform struct {
    position: math.Vec2f,
    scale: u32
}

def (t: *Transform) update_with_vel(velocity: math.Vec2f) {
    t.position = t.position.add(velocity);
}

type Player struct {
    transform: Transform,
    velocity: math.Vec2f,
    speed: f32,
    flip: sdl.RendererFlip,

    current_animation: *g.Animation,
    idle_animation: g.Animation,
    run_down_animation: g.Animation,
    run_up_animation: g.Animation,
    run_horizontal_animation: g.Animation,
    spritesheet: g.SpriteSheet
}

def load(renderer: *sdl.Renderer, init_x: u32, init_y: u32): Player {
    let spec = g.spritesheet_spec(16, 16, "res/girl.png");
    let player_spritesheet: g.SpriteSheet = undefined;
    if !g.load_spritesheet_from_png(renderer, spec, &player_spritesheet) {
        io.printf("Could not load sprite: %s\n", sdl.get_error());
        return undefined;
    }

    let player_idle = g.create_animation(&player_spritesheet, 4, 0);
    let player_run_down = g.create_animation(&player_spritesheet, 6, 4);
    let player_run_up = g.create_animation(&player_spritesheet, 6, 10);
    let player_run_horizontal = g.create_animation(&player_spritesheet, 6, 16);
    let initial_pos = math.vec2f(init_x as f32, init_y as f32);

    return Player {
        transform: Transform { position: initial_pos, scale: config.scale() },
        velocity: math.zero_vec2f(),
        speed: 2.0,
        flip: sdl.RendererFlip.None,
        current_animation: null,
        idle_animation: player_idle,
        run_down_animation: player_run_down,
        run_up_animation: player_run_up,
        run_horizontal_animation: player_run_horizontal,
        spritesheet: player_spritesheet
    };
}

def (p: *Player) render(renderer: *sdl.Renderer) {
    let src = sdl.Rect {
        x: p.transform.position.x as i32,
        y: p.transform.position.y as i32,
        w: p.transform.scale as i32 * 16,
        h: p.transform.scale as i32 * 16
    };
    g.render_sprite(renderer, p.current_animation.current_sprite(), src, p.flip);
}

def (p: *Player) free() {
    p.idle_animation.free();
    p.run_down_animation.free();
    p.run_up_animation.free();
    p.run_horizontal_animation.free();
    p.spritesheet.free();
}

def (p: *Player) update(ts: f32, input: *i.InputState) {
    p.velocity = math.zero_vec2f();
    p.current_animation.update(ts);
    p.current_animation = &p.idle_animation;

    if input.is_action_pressed(i.Action.Left) {
        p.velocity.x -= 1.0;
        p.flip = sdl.RendererFlip.Horizontal;
        p.current_animation = &p.run_horizontal_animation;
    }

    if input.is_action_pressed(i.Action.Right) {
        p.velocity.x += 1.0;
        p.flip = sdl.RendererFlip.None;
        p.current_animation = &p.run_horizontal_animation;
    }

    if input.is_action_pressed(i.Action.Up) {
        p.velocity.y -= 1.0;
        p.current_animation = &p.run_up_animation;
    }

    if input.is_action_pressed(i.Action.Down) {
        p.velocity.y += 1.0;
        p.current_animation = &p.run_down_animation;
    }

    p.velocity = p.velocity.normalized().times(p.speed);
    p.transform.update_with_vel(p.velocity);
}
