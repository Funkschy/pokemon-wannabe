import "io";
import "sdl";
import "npc";
import "math";
import "world";
import "config";
import "physics";
import "input" as i;
import "graphics" as g;

let interaction_cooldown: i64 = 500000000;

type Player struct {
    transform: physics.Transform,
    velocity: math.Vec2f,
    speed: f32,
    flip: sdl.RendererFlip,
    hitbox: physics.Hitbox,
    last_interact: i64,
    interacting: bool,

    current_animation: *g.Animation,
    idle_animation: g.Animation,
    run_down_animation: g.Animation,
    run_up_animation: g.Animation,
    run_horizontal_animation: g.Animation,
    spritesheet: g.SpriteSheet
}

def load(renderer: *sdl.Renderer, init_x: u32, init_y: u32): Player {
    let spec = g.spritesheet_spec(16, 16, "res/girl.png");
    let player_spritesheet: g.SpriteSheet = undefined;
    if !g.load_spritesheet_from_png(renderer, spec, &player_spritesheet) {
        io.printf("Could not load sprite: %s\n", sdl.get_error());
        return undefined;
    }

    let player_idle = g.create_animation(&player_spritesheet, 4, 0);
    let player_run_down = g.create_animation(&player_spritesheet, 6, 4);
    let player_run_up = g.create_animation(&player_spritesheet, 6, 10);
    let player_run_horizontal = g.create_animation(&player_spritesheet, 6, 16);
    let initial_pos = math.vec2f(init_x as f32, init_y as f32);

    return Player {
        transform: physics.Transform { position: initial_pos, scale: config.scale() },
        velocity: math.zero_vec2f(),
        speed: 0.5,
        flip: sdl.RendererFlip.None,
        hitbox: physics.hitbox(0, 0, 16, 16),
        last_interact: 0,
        interacting: false,

        current_animation: null,
        idle_animation: player_idle,
        run_down_animation: player_run_down,
        run_up_animation: player_run_up,
        run_horizontal_animation: player_run_horizontal,
        spritesheet: player_spritesheet
    };
}

def (p: *Player) render(renderer: *sdl.Renderer) {
    let src = sdl.Rect {
        x: p.transform.position.x as i32,
        y: p.transform.position.y as i32,
        w: p.transform.scale as i32 * 16,
        h: p.transform.scale as i32 * 16
    };
    g.render_sprite(renderer, p.current_animation.current_sprite(), src, p.flip);
}

def (p: *Player) free() {
    p.idle_animation.free();
    p.run_down_animation.free();
    p.run_up_animation.free();
    p.run_horizontal_animation.free();
    p.spritesheet.free();
}

def (p: *Player) update(ts: f32, input: *i.InputState, w: *world.World) {
    p.velocity = math.zero_vec2f();
    p.current_animation.update(ts);
    p.current_animation = &p.idle_animation;

    if !p.interacting {
        if input.is_action_pressed(i.Action.Left) {
            p.velocity.x -= 1.0;
            p.flip = sdl.RendererFlip.Horizontal;
            p.current_animation = &p.run_horizontal_animation;
        }

        if input.is_action_pressed(i.Action.Right) {
            p.velocity.x += 1.0;
            p.flip = sdl.RendererFlip.None;
            p.current_animation = &p.run_horizontal_animation;
        }

        if input.is_action_pressed(i.Action.Up) {
            p.velocity.y -= 1.0;
            p.current_animation = &p.run_up_animation;
        }

        if input.is_action_pressed(i.Action.Down) {
            p.velocity.y += 1.0;
            p.current_animation = &p.run_down_animation;
        }

        p.velocity = p.velocity.normalized().times(p.speed);
        p.transform.update_with_vel(p.velocity, ts);
    }

    let now = sdl.now();
    let can_interact = now - p.last_interact > interaction_cooldown;
    if input.is_action_pressed(i.Action.Interact) && can_interact {
        p.last_interact = now;

        if w.current_text.len == 0 {
            let hitbox = p.hitbox.as_absolute_rect(p.transform);
            hitbox.x /= (config.scale() * config.tile_size()) as i32;
            hitbox.y /= (config.scale() * config.tile_size()) as i32;

            for let y = hitbox.y - 1; y < hitbox.y + 3; y += 1 {
                for let x = hitbox.x - 1; x < hitbox.x + 3; x += 1 {
                    let tile = w.get_tile(x as u32, y as u32);

                    if tile.kind == world.TileState.HasDialogNpc {
                        let npc = tile.data as *npc.Npc;
                        w.set_text(npc.data.with_dialog.dialog_text.view());
                        p.interacting = true;

                        x += 100000;
                        break;
                    }
                }
            }
        }

        if w.scroll_text() {
            p.interacting = false;
        }
    }
}

def (p: *Player) resolve_collision(other: sdl.Rect) {
    let hitbox = p.hitbox.as_absolute_rect(p.transform);

    let p_x1 = hitbox.x;
    let p_x2 = hitbox.x + hitbox.w;
    let p_y1 = hitbox.y;
    let p_y2 = hitbox.y + hitbox.h;

    let o_x1 = other.x;
    let o_x2 = other.x + other.w;
    let o_y1 = other.y;
    let o_y2 = other.y + other.h;

    let h_collision = math.max(0, math.min(p_x2, o_x2) - math.max(p_x1, o_x1));
    let v_collision = math.max(0, math.min(p_y2, o_y2) - math.max(p_y1, o_y1));

    if h_collision < v_collision {
        let is_left = (hitbox.x < other.x);
        if is_left {
            h_collision *= -1;
        }
        p.transform.position.x += h_collision as f32;
    } else {
        let is_over = (hitbox.y < other.y);
        if is_over {
            v_collision *= -1;
        }
        p.transform.position.y += v_collision as f32;
    }
}
