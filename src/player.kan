import "io";
import "sdl";
import "math";
import "world";
import "config";
import "physics";
import "input" as i;
import "graphics" as g;

let interaction_cooldown: i64 = 500000000;

type Player struct {
    transform: physics.Transform,
    velocity: math.Vec2f,
    speed: f32,
    flip: sdl.RendererFlip,
    hitbox: physics.Hitbox,
    last_interact: i64,

    current_animation: *g.Animation,
    idle_animation: g.Animation,
    run_down_animation: g.Animation,
    run_up_animation: g.Animation,
    run_horizontal_animation: g.Animation,
    spritesheet: g.SpriteSheet
}

def load(renderer: *sdl.Renderer, init_x: u32, init_y: u32): Player {
    let spec = g.spritesheet_spec(16, 16, "res/girl.png");
    let player_spritesheet: g.SpriteSheet = undefined;
    if !g.load_spritesheet_from_png(renderer, spec, &player_spritesheet) {
        io.printf("Could not load sprite: %s\n", sdl.get_error());
        return undefined;
    }

    let player_idle = g.create_animation(&player_spritesheet, 4, 0);
    let player_run_down = g.create_animation(&player_spritesheet, 6, 4);
    let player_run_up = g.create_animation(&player_spritesheet, 6, 10);
    let player_run_horizontal = g.create_animation(&player_spritesheet, 6, 16);
    let initial_pos = math.vec2f(init_x as f32, init_y as f32);

    return Player {
        transform: physics.Transform { position: initial_pos, scale: config.scale() },
        velocity: math.zero_vec2f(),
        speed: 0.5,
        flip: sdl.RendererFlip.None,
        hitbox: physics.hitbox(0, 0, 16, 16),
        last_interact: 0,

        current_animation: null,
        idle_animation: player_idle,
        run_down_animation: player_run_down,
        run_up_animation: player_run_up,
        run_horizontal_animation: player_run_horizontal,
        spritesheet: player_spritesheet
    };
}

def (p: *Player) render(renderer: *sdl.Renderer) {
    let src = sdl.Rect {
        x: p.transform.position.x as i32,
        y: p.transform.position.y as i32,
        w: p.transform.scale as i32 * 16,
        h: p.transform.scale as i32 * 16
    };
    g.render_sprite(renderer, p.current_animation.current_sprite(), src, p.flip);
}

def (p: *Player) free() {
    p.idle_animation.free();
    p.run_down_animation.free();
    p.run_up_animation.free();
    p.run_horizontal_animation.free();
    p.spritesheet.free();
}

def (p: *Player) update(ts: f32, input: *i.InputState, world: *world.World) {
    p.velocity = math.zero_vec2f();
    p.current_animation.update(ts);
    p.current_animation = &p.idle_animation;

    if input.is_action_pressed(i.Action.Left) {
        p.velocity.x -= 1.0;
        p.flip = sdl.RendererFlip.Horizontal;
        p.current_animation = &p.run_horizontal_animation;
    }

    if input.is_action_pressed(i.Action.Right) {
        p.velocity.x += 1.0;
        p.flip = sdl.RendererFlip.None;
        p.current_animation = &p.run_horizontal_animation;
    }

    if input.is_action_pressed(i.Action.Up) {
        p.velocity.y -= 1.0;
        p.current_animation = &p.run_up_animation;
    }

    if input.is_action_pressed(i.Action.Down) {
        p.velocity.y += 1.0;
        p.current_animation = &p.run_down_animation;
    }

    p.velocity = p.velocity.normalized().times(p.speed);
    p.transform.update_with_vel(p.velocity, ts);

    let now = sdl.now();
    if input.is_action_pressed(i.Action.Interact) && now - p.last_interact > interaction_cooldown {
        p.last_interact = now;
        io.printf("kek\n");
    }
}

def (p: *Player) collides_with(other: sdl.Rect): bool {
    let hitbox = p.hitbox.as_absolute_rect(p.transform);
    let is_inside_horizontal = hitbox.is_inside_horizontal(other);
    let is_inside_vertical = hitbox.is_inside_vertical(other);

    return is_inside_horizontal && is_inside_vertical;
}
