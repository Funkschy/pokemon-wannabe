import "io";
import "sdl";
import "str";
import "math";
import "config";
import "physics";
import "graphics" as g;
import "behaviour" as _;

type Kind enum {
    Basic, WithDialog, Enemy
}

type NpcData union {
    basic: Basic,
    with_dialog: WithDialog,
    enemy: Enemy
}

type Npc struct {
    kind: Kind,
    data: NpcData
}

type Basic struct {
    flip: sdl.RendererFlip,
    animation: g.Animation,
    hitbox: physics.Hitbox,
    transform: physics.Transform
}

def load(
    renderer: *sdl.Renderer,
    kind: Kind,
    animation: string,
    count: u32,
    x: u32,
    y: u32
): *Npc {
    let spec = g.spritesheet_spec(16, 16, animation);
    let npc_spritesheet: g.SpriteSheet = undefined;
    if !g.load_spritesheet_from_png(renderer, spec, &npc_spritesheet) {
        io.printf("Could not load sprite: %s\n", sdl.get_error());
        return null;
    }

    let scale = config.scale() * config.tile_size();
    let basic = Basic {
        flip: sdl.RendererFlip.None,
        animation: g.create_animation(&npc_spritesheet, count, 0),
        hitbox: physics.hitbox (0, 0, 16, 16),
        transform: physics.Transform {
            position: math.vec2f(scale * x as f32, scale * y as f32),
            scale: config.scale()
        }
    };

    if kind == Kind.WithDialog {
        let with_dialog = WithDialog { basic: basic, dialog_text: str.from("") };
        return new Npc {
            kind: kind,
            data: NpcData { with_dialog: with_dialog }
        };
    }

    if kind == Kind.Enemy {
        let enemy = Enemy { basic: basic, behaviour: do_nothing() };
        return new Npc {
            kind: kind,
            data: NpcData { enemy: enemy }
        };
    }

    return new Npc {
        kind: kind,
        data: NpcData { basic: basic }
    };
}

def (n: *Npc) free() {
    if n.kind == Kind.Basic {
        n.data.basic.animation.free();
    } else if n.kind == Kind.WithDialog {
        n.data.with_dialog.basic.animation.free();
        n.data.with_dialog.dialog_text.free();
    }
}

def (n: *Npc) update(ts: f32) {
    n.data.basic.animation.update(ts);
    if n.kind == Kind.Enemy {
        n.data.enemy.behaviour.act();
    }
}

def (n: *Npc) render(renderer: *sdl.Renderer) {
    let b = &n.data as *Basic;
    let src = sdl.Rect {
        x: b.transform.position.x as i32,
        y: b.transform.position.y as i32,
        w: b.transform.scale as i32 * 16,
        h: b.transform.scale as i32 * 16
    };
    g.render_sprite(renderer, b.animation.current_sprite(), src, b.flip);
}

def (n: *Npc) abs_rect(): sdl.Rect {
    let b = &n.data as *Basic;
    return b.hitbox.as_absolute_rect(b.transform);
}

def (n: *Npc) tile_rect(): sdl.Rect {
    let b = &n.data as *Basic;
    return physics.tile_rect(b.transform, b.hitbox);
}

type WithDialog struct {
    basic: Basic,
    dialog_text: str.String
}

type Enemy struct {
    basic: Basic,
    behaviour: Behaviour
}
