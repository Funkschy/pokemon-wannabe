import "io";
import "str";
import "std";
import "npc";
import "sdl";
import "text";
import "ptrvec";
import "config";
import "objects" as o;
import "graphics" as g;

type TileState enum {
    Empty, Object, HasNpc, HasDialogNpc
}

type Tile struct {
    kind: TileState,
    data: *void
}

type World struct {
    width_units: u32,
    height_units: u32,
    text_stopped_at: usize,
    ground: g.SpriteSheet,
    current_ground: g.Sprite,
    current_wall: g.Sprite,
    tiles: *Tile,
    current_text: str.View,
    textbox: text.TextBox,
    npcs: ptrvec.Vec, // ptrvec.Vec<*npc.Npc>
    objects: ptrvec.Vec // ptrvec.Vec<*o.Object>
}

def create(renderer: *sdl.Renderer, width_units: u32, height_units: u32): World {
    let spec = g.spritesheet_spec(config.tile_size() as i32, config.tile_size() as i32, "res/background.png");
    let background_spritesheet: g.SpriteSheet = undefined;
    if !g.load_spritesheet_from_png(renderer, spec, &background_spritesheet) {
        io.printf("Could not load sprite: %s\n", sdl.get_error());
        return undefined;
    }

    return World {
        width_units: width_units,
        height_units: height_units,
        text_stopped_at: 0,
        ground: background_spritesheet,
        current_ground: background_spritesheet.get(1, 0),
        current_wall: background_spritesheet.get(0, 2),
        tiles: std.calloc((width_units * height_units) as usize, sizeof Tile) as *Tile,
        current_text: str.view(0, ""),
        textbox: text.load(renderer),
        npcs: ptrvec.create(),
        objects: ptrvec.create()
    };
}

def (w: *World) free() {
    delete w.tiles;
    for let i: usize = 0; i < w.npcs.len; i += 1 {
        let npc = w.npcs.get(i) as *npc.Npc;
        npc.free();
    }
    for let i: usize = 0; i < w.objects.len; i += 1 {
        delete w.objects.get(i);
    }
    w.npcs.free();
    w.objects.free();
    w.textbox.free();
    w.ground.free();
}

def (w: *World) add_object(obj: *o.Object) {
    w.objects.push_ptr(obj as *void);
    let obj_rect = obj.tile_rect();

    for let y = obj_rect.y; y < obj_rect.y + obj_rect.h; y += 1 {
        for let x = obj_rect.x; x < obj_rect.x + obj_rect.w; x += 1 {
            let idx = y as u32 * w.width_units + x as u32;

            *(w.tiles + idx) = Tile { kind: TileState.Object, data: obj as *void };
        }
    }
}

def (w: *World) add_npc(new_npc: *npc.Npc) {
    w.npcs.push_ptr(new_npc as *void);
    let npc_rect = new_npc.tile_rect();
    let kind = TileState.HasNpc;
    if new_npc.kind == npc.Kind.WithDialog {
        kind = TileState.HasDialogNpc;
    }

    for let y = npc_rect.y; y < npc_rect.y + npc_rect.h; y += 1 {
        for let x = npc_rect.x; x < npc_rect.x + npc_rect.w; x += 1 {
            let idx = y as u32 * w.width_units + x as u32;

            *(w.tiles + idx) = Tile { kind: kind, data: new_npc as *void };
        }
    }
}

def (w: *World) get_tile(x: u32, y: u32): Tile {
    let idx = y * w.width_units + x;
    return *(w.tiles + idx);
}

def (w: *World) set_text(text: str.View) {
    w.current_text = text;
    w.text_stopped_at = 0;
}

def (w: *World) scroll_text(): bool {
    if w.current_text.len == 0 || w.text_stopped_at == 0 {
        return false;
    }

    w.current_text.data += w.text_stopped_at;
    w.current_text.len -= w.text_stopped_at;
    return w.current_text.len == 0 || w.text_stopped_at == 0;
}

def (w: *World) render_background(renderer: *sdl.Renderer) {
    let sprite = &w.current_wall;
    let scale = config.tile_size() * config.scale() as i32;

    for let y: u32 = 0; y < w.height_units; y += 1 {
        if y > 1 {
            sprite = &w.current_ground;
        }

        for let x: u32 = 0; x < w.width_units; x += 1 {
            let dest = sdl.Rect {
                x: x as i32 * scale,
                y: y as i32 * scale,
                w: scale,
                h: scale
            };
            g.render_sprite(renderer, sprite, dest, sdl.RendererFlip.None);
        }

        // first ground row just rendered
        if y == 2 {
            let line = sdl.Rect {
                x: 0,
                y: scale * 2,
                w: config.pixel_width() as i32,
                h: config.scale() as i32
            };
            renderer.fill_rect(&line);
        }
    }
}

def (w: *World) render_hud(renderer: *sdl.Renderer) {
    if w.current_text.len == 0 {
        return;
    }

    w.text_stopped_at = w.textbox.render(renderer, w.current_text, 5);
}
