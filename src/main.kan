import ":std/io";
import ":std/str";

import "sdl";
import "res";
import "text";
import "math";
import "config";
import "ecs" as _;
import "arena";
import "input" as i;
import "systems" as s;
import "physics" as p;
import "graphics" as g;
import "components" as _;

delegate def MainLoop(arg: *Game): bool;
extern def emscripten_set_main_loop_arg(loop: MainLoop, arg: *Game, fps: i32, simulate_inf_loop: i32);
extern def exit(rc: i32);

type Game struct {
    debug: bool,
    renderer: *sdl.Renderer,
    window: *sdl.Window,
    last: i64,
    input: i.InputState,
    ecs: ECS
}

def mainloop(g: *Game): bool {
    let e: sdl.Event = undefined;
    let delta = sdl.delta(g.last) as f32;
    g.last = sdl.now();

    while e.poll() != 0 {
        if e.common.kind == sdl.EventKind.Quit {
            return false;
        }

        if e.common.kind == sdl.EventKind.KeyDown && e.key_event.keysym.sym == 'g' {
            g.debug = !g.debug;
            io.printf("debug %d\n", g.debug);
            continue;
        }

        g.input.update_input_map(e);
    }

    g.renderer.set_draw_color(0, 19, 26, 255);
    g.renderer.clear();

    for let i: usize = 0; i < g.ecs.num_systems(); i += 1 {
        g.ecs.get_system(i).update(delta);
    }
    g.renderer.present();

    return true;
}

def main() {
    if sdl.init(sdl.init_video() | sdl.init_joystick()) < 0 {
        io.printf("Could not init SDL: %s\n", sdl.get_error());
        return;
    }
    defer sdl.quit();

    let flags = sdl.init_png();
    if (sdl.img_init(flags) & flags) != flags {
        io.printf("Coult not init SDL_Image\n");
        return;
    }
    defer sdl.img_quit();

    let display_mode = sdl.get_desktop_display_mode();

    let width = config.width();
    let height = config.height();

    let window = sdl.create_window(
        "Quasi Pokemon",
        sdl.window_centered(), sdl.window_centered(),
        display_mode.w / 2, display_mode.h / 2,
        sdl.window_shown() | sdl.window_resizeable()
    );

    if window == null {
        io.printf("Could not init window: %s\n", sdl.get_error());
        return;
    }
    defer window.destroy();

    let renderer = sdl.create_renderer(window, -1, sdl.present_vsync());
    renderer.set_draw_color(0, 19, 26, 255);
    defer renderer.destroy();

    renderer.set_logical_size(config.width(), config.height());
    renderer.set_integer_scale(true);

    let game: Game = undefined;
    game.debug = false;
    game.renderer = renderer;
    game.window = window;

    res.init_spritesheet_specs();
    res.load_spritesheets(game.renderer);
    defer res.free();

    let player_animations = arena.typed(sizeof g.Animation);
    defer player_animations.free();


    let player_spritesheet = res.get(res.Resource.GirlSpriteSheet);
    let player_idle = g.create_animation(player_spritesheet, 4, 0);
    defer player_idle.free();
    let player_run_down = g.create_animation(player_spritesheet, 6, 4);
    defer player_run_down.free();
    let player_run_up = g.create_animation(player_spritesheet, 6, 10);
    defer player_run_up.free();
    let player_run_horizontal = g.create_animation(player_spritesheet, 6, 16);
    defer player_run_horizontal.free();

    let player_anim: [4]g.Animation = undefined;
    player_anim[0] = player_idle;
    player_anim[1] = player_run_down;
    player_anim[2] = player_run_up;
    player_anim[3] = player_run_horizontal;

    let player_graphics = g.simple_anime(&player_anim[0], 4);

    let initial_pos = math.vec2f(5.0, 5.0);
    let player_transform = p.Transform { position: initial_pos };
    let player_hitbox = p.hitbox(0, 0, 16, 16);

    let input = Input {
        last_interact: 0,
        interacting: false
    };

    let player_movement = p.Movement {
        velocity: math.zero_vec2f(),
        speed: 0.1
    };

    game.ecs = create_ecs();
    defer game.ecs.free();

    let textbox = text.load(game.renderer);
    defer textbox.free();

    // systems are popped last to first, so the last sys runs first
    let repeated_render_sys = s.repeated_render_system(&game.ecs, game.renderer);
    game.ecs.add_system(&repeated_render_sys.s);

    let anim_render_sys = s.animation_render_system(&game.ecs, game.renderer);
    game.ecs.add_system(&anim_render_sys.s);

    let sprite_render_sys = s.sprite_render_system(&game.ecs, game.renderer);
    game.ecs.add_system(&sprite_render_sys.s);

    let text_render_sys = s.text_render_system(&game.ecs, game.renderer);
    game.ecs.add_system(&text_render_sys.s);

    let movement_sys = s.movement_system(&game.ecs);
    game.ecs.add_system(&movement_sys.s);

    let input_sys = s.input_system(&game.ecs, &game.input);
    game.ecs.add_system(&input_sys.s);

    let collision_sys = s.collision_system(&game.ecs);
    game.ecs.add_system(&collision_sys.s);

    let interaction_sys = s.interaction_system(&game.ecs, &game.input);
    game.ecs.add_system(&interaction_sys.s);

    let debug_render_sys = s.debug_render_system(&game.ecs, game.renderer, &game.debug, textbox.font);
    game.ecs.add_system(&debug_render_sys.s);

    // --- player ---
    let player = game.ecs.create_entity();
    game.ecs.add_component_to_entity(player, ComponentKind.Input, &input as *void);
    game.ecs.add_component_to_entity(player, ComponentKind.Movement, &player_movement as *void);
    game.ecs.add_component_to_entity(player, ComponentKind.AnimatedGraphics, &player_graphics as *void);
    game.ecs.add_component_to_entity(player, ComponentKind.Transform, &player_transform as *void);
    game.ecs.add_component_to_entity(player, ComponentKind.Hitbox, &player_hitbox as *void);

    let npc_hitbox = p.hitbox (0, 0, 16, 16);

    let textbox_component = TextBox {
        textbox: &textbox
    };

    // --- cat ---
    let cat_anim = g.create_animation(res.get(res.Resource.CatSpriteSheet), 8, 0);
    defer cat_anim.free();
    let cat_graphics = g.simple_anime(&cat_anim, 1);

    let cat_dialog = Interaction {
        hitbox: p.hitbox (-8, -8, 32, 32),
        chars_shown: 0,
        last_state: 0,
        current_state: 0
    };

    let cat_dialog_text = str.view_from("Meow\n\n\nHey Kid\nyou got some Catnip?");

    let cat_initial_pos = math.vec2f(30.0, 60.0);
    let cat_transform = p.Transform { position: cat_initial_pos };

    let cat = game.ecs.create_entity();
    game.ecs.add_component_to_entity(cat, ComponentKind.AnimatedGraphics, &cat_graphics as *void);
    game.ecs.add_component_to_entity(cat, ComponentKind.Transform, &cat_transform as *void);
    game.ecs.add_component_to_entity(cat, ComponentKind.Hitbox, &npc_hitbox as *void);
    game.ecs.add_component_to_entity(cat, ComponentKind.Interaction, &cat_dialog as *void);

    let cat_text = game.ecs.create_entity();
    game.ecs.add_component_to_entity(cat_text, ComponentKind.TextBox, &textbox_component as *void);
    game.ecs.add_component_to_entity(cat_text, ComponentKind.Interaction, &cat_dialog as *void);
    game.ecs.add_component_to_entity(cat_text, ComponentKind.StrView, &cat_dialog_text as *void);

    // --- thot ---
    let thot_anim = g.create_animation(res.get(res.Resource.ThotSpriteSheet), 8, 0);
    defer thot_anim.free();
    let thot_graphics = g.simple_anime(&thot_anim, 1);
    let thot_transform = p.Transform { position: math.vec2f(100.0, 100.0) };

    let thot_dialog = Interaction {
        hitbox: p.hitbox (-8, -8, 32, 32),
        chars_shown: 0,
        last_state: 0,
        current_state: 0
    };

    let thot_dialog_text = str.view_from(
        "Follow me on twitch, Instagram, Snapchat, Twitter, Youtube\nand onlyfans"
    );

    let thot = game.ecs.create_entity();
    game.ecs.add_component_to_entity(thot, ComponentKind.Hitbox, &npc_hitbox as *void);
    game.ecs.add_component_to_entity(thot, ComponentKind.Transform, &thot_transform as *void);
    game.ecs.add_component_to_entity(thot, ComponentKind.AnimatedGraphics, &thot_graphics as *void);
    game.ecs.add_component_to_entity(thot, ComponentKind.Interaction, &thot_dialog as *void);

    let thot_text = game.ecs.create_entity();
    game.ecs.add_component_to_entity(thot_text, ComponentKind.TextBox, &textbox_component as *void);
    game.ecs.add_component_to_entity(thot_text, ComponentKind.Interaction, &thot_dialog as *void);
    game.ecs.add_component_to_entity(thot_text, ComponentKind.StrView, &thot_dialog_text as *void);

    // --- wall ---
    let background_spritesheet = res.get(res.Resource.BackgroundSpriteSheet);

    let wall_h = 16;
    let wall_transform = p.Transform {
        position: math.vec2f(0.0, 0.0)
    };
    let wall_sprite = background_spritesheet.get(0, 0);
    let wall_graphics = g.Graphics {
        sprite: &wall_sprite,
        flip: sdl.RendererFlip.None
    };

    let wall_rep = g.RepeatedGraphics {
        inner: wall_graphics,
        reps_w: config.width() / 8,
        reps_h: 2
    };
    let wall_hitbox = p.hitbox (0, 0, config.width(), wall_h);

    let wall = game.ecs.create_entity();
    game.ecs.add_component_to_entity(wall, ComponentKind.Transform, &wall_transform as *void);
    game.ecs.add_component_to_entity(wall, ComponentKind.RepeatedGraphics, &wall_rep as *void);
    game.ecs.add_component_to_entity(wall, ComponentKind.Hitbox, &wall_hitbox as *void);

    // --- floor ---
    let floor_transform = p.Transform {
        position: math.vec2f(0.0, wall_h as f32)
    };
    let floor_sprite = background_spritesheet.get(1, 0);
    let floor_graphics = g.Graphics {
        sprite: &floor_sprite,
        flip: sdl.RendererFlip.None
    };

    let floor_rep = g.RepeatedGraphics {
        inner: floor_graphics,
        reps_w: config.width() / 8,
        reps_h: (config.height() - wall_h) / 8
    };

    let floor = game.ecs.create_entity();
    game.ecs.add_component_to_entity(floor, ComponentKind.Transform, &floor_transform as *void);
    game.ecs.add_component_to_entity(floor, ComponentKind.RepeatedGraphics, &floor_rep as *void);

    // --- Clock ---

    let clock_sprite = res.get(res.Resource.ClockSpriteSheet).get(0, 0);
    let clock_graphics = g.Graphics {
        sprite: &clock_sprite,
        flip: sdl.RendererFlip.None
    };
    let clock_initial_pos = math.vec2f(120.0, 0.0);
    let clock_transform = p.Transform { position: clock_initial_pos };
    let clock_hitbox = p.hitbox (0, 16, 16, 16);

    let clock = game.ecs.create_entity();
    game.ecs.add_component_to_entity(clock, ComponentKind.Transform, &clock_transform as *void);
    game.ecs.add_component_to_entity(clock, ComponentKind.Graphics, &clock_graphics as *void);
    game.ecs.add_component_to_entity(clock, ComponentKind.Hitbox, &clock_hitbox as *void);

    game.last = sdl.now();
    game.input = i.init_input_map();
    defer game.input.free();

    let running = true;
    while running {
        running = mainloop(&game);
    }

    // emscripten_set_main_loop_arg(&mainloop, &game, -1, 1);
}
