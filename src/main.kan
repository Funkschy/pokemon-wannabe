import "io";
import "sdl";
import "str";
import "npc";
import "room";
import "config";
import "input" as i;
import "player" as p;
import "objects" as o;
import "graphics" as g;

delegate def MainLoop(arg: *Game);
extern def emscripten_set_main_loop_arg(loop: MainLoop, arg: *Game, fps: i32, simulate_inf_loop: i32);
extern def exit(rc: i32);

type Game struct {
    debug: bool,
    renderer: *sdl.Renderer,
    window: *sdl.Window,
    room: room.Room,
    last: i64,
    input: i.InputState,

    player: p.Player
}

def mainloop(g: *Game) {
    let e: sdl.Event = undefined;
    let delta = sdl.delta(g.last) as f32;
    g.last = sdl.now();

    while e.poll() != 0 {
        if e.common.kind == sdl.EventKind.Quit {
            exit(0);
        }

        if e.common.kind == sdl.EventKind.KeyDown && e.key_event.keysym.sym == 'g' {
            g.debug = !g.debug;
            io.printf("debug %d\n", g.debug);
            continue;
        }

        g.input.update_input_map(e);
    }

    g.player.update(delta, &g.input, &g.room);

    g.renderer.clear();
    g.room.render_background(g.renderer);

    if g.debug {
        g.renderer.set_draw_color(255, 0, 0, 255);
    }

    for let i: usize = 0; i < g.room.objects.len; i += 1 {
        let obj = g.room.objects.get(i) as *o.Object;
        g.player.resolve_collision(obj.abs_rect());
        obj.render(g.renderer);

        if g.debug {
            let rect = obj.abs_rect();
            g.renderer.draw_rect(&rect);
        }
    }

    for let i: usize = 0; i < g.room.npcs.len; i += 1 {
        let npc = g.room.npcs.get(i) as *npc.Npc;
        npc.update(delta);
        g.player.resolve_collision(npc.abs_rect());
        npc.render(g.renderer);

        if g.debug {
            let rect = npc.abs_rect();
            g.renderer.draw_rect(&rect);
        }
    }

    g.player.render(g.renderer);
    if g.debug {
        let rect = g.player.abs_rect();
        g.renderer.draw_rect(&rect);
    }

    g.renderer.set_draw_color(0, 19, 26, 255);
    g.room.render_hud(g.renderer);

    g.renderer.present();
}

def main() {
    if sdl.init(sdl.init_video() | sdl.init_joystick()) < 0 {
        io.printf("Could not init SDL: %s\n", sdl.get_error());
        return;
    }
    defer sdl.quit();

    let flags = sdl.init_png();
    if (sdl.img_init(flags) & flags) != flags {
        io.printf("Coult not init SDL_Image\n");
        return;
    }
    defer sdl.img_quit();

    let display_mode = sdl.get_desktop_display_mode();
    config.set_scale(display_mode.h as u32 / config.pixel_height() / 2);

    let width = config.pixel_width();
    let height = config.pixel_height();

    let window = sdl.create_window(
        "Quasi Pokemon",
        sdl.window_centered(), sdl.window_centered(),
        width, height,
        sdl.window_shown()
    );

    if window == null {
        io.printf("Could not init window: %s\n", sdl.get_error());
        return;
    }
    defer window.destroy();

    let renderer = sdl.create_renderer(window, -1, sdl.present_vsync());
    renderer.set_draw_color(0, 19, 26, 255);
    defer renderer.destroy();

    // let joystick: *sdl.Joystick = null;
    // if sdl.num_joysticks() > 0 && (joystick = sdl.open_joystick(0)) == null {
    //     io.printf("Could not open joystick: %s\n", sdl.get_error());
    //     return;
    // }
    // defer joystick.close();

    let game: Game = undefined;
    game.debug = false;
    game.renderer = renderer;
    game.window = window;

    game.room = room.create(
        renderer,
        config.width() / config.tile_size(),
        config.height() / config.tile_size()
    );
    defer game.room.free();
    let room = &game.room;

    game.player = p.load(renderer, width / 2, height / 2);
    defer game.player.free();
    game.player.current_animation = &game.player.idle_animation;

    let cat = npc.load(renderer, npc.Kind.WithDialog, "res/cat.png", 8, 3, 1);
    cat.data.with_dialog.dialog_text = str.from(
        "Meow\n\n\nHey Kid\nyou got some Catnip?"
    );
    cat.data.with_dialog.basic.flip = sdl.RendererFlip.Horizontal;
    room.add_npc(cat);

    let thot = npc.load(renderer, npc.Kind.WithDialog, "res/thot.png", 12, 14, 5);

    thot.data.with_dialog.dialog_text = str.from(
        "Follow me on twitch, Instagram, Snapchat, Twitter, Youtube\nand onlyfans"
    );
    room.add_npc(thot);

    let bed = o.load_simple(renderer, 1, 1, 16, 32, "res/bed.png");
    room.add_object(bed);
    let clock = o.load_simple(renderer, 18, 0, 16, 32, "res/clock.png");
    room.add_object(clock);
    let table = o.load_simple(renderer, 10, 9, 16, 32, "res/table.png");
    room.add_object(table);

    let wall = o.init_trigger(0, 0, config.width(), 16);
    room.add_object(wall);

    game.last = sdl.now();
    game.input = i.init_input_map();

    // while true {
    //     mainloop(&game);
    // }

    emscripten_set_main_loop_arg(&mainloop, &game, -1, 1);
}
