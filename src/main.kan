import "io";
import "sdl";
import "str";
import "npc";
import "room";
import "math";
import "config";
import "ecs" as _;
import "arena";
import "input" as i;
import "systems" as s;
import "objects" as o;
import "physics" as p;
import "graphics" as g;
import "components" as _;

delegate def MainLoop(arg: *Game): bool;
extern def emscripten_set_main_loop_arg(loop: MainLoop, arg: *Game, fps: i32, simulate_inf_loop: i32);
extern def exit(rc: i32);

type Game struct {
    debug: bool,
    renderer: *sdl.Renderer,
    window: *sdl.Window,
    last: i64,
    input: i.InputState,
    ecs: ECS
}

def mainloop(g: *Game): bool {
    let e: sdl.Event = undefined;
    let delta = sdl.delta(g.last) as f32;
    g.last = sdl.now();

    while e.poll() != 0 {
        if e.common.kind == sdl.EventKind.Quit {
            return false;
        }

        if e.common.kind == sdl.EventKind.KeyDown && e.key_event.keysym.sym == 'g' {
            g.debug = !g.debug;
            io.printf("debug %d\n", g.debug);
            continue;
        }

        g.input.update_input_map(e);
    }

    for let i: usize = 0; i < g.ecs.num_systems(); i += 1 {
        g.ecs.get_system(i).update(delta);
    }

    // g.player.update(delta, &g.input, &g.room);

    // g.room.render_background(g.renderer);

    // if g.debug {
    //     g.renderer.set_draw_color(255, 0, 0, 255);
    // }

    // for let i: usize = 0; i < g.room.objects.len; i += 1 {
    //     let obj = g.room.objects.get(i) as *o.Object;
    //     g.player.resolve_collision(obj.abs_rect());
    //     obj.render(g.renderer);

    //     if g.debug {
    //         let rect = obj.abs_rect();
    //         g.renderer.draw_rect(&rect);
    //     }
    // }

    // for let i: usize = 0; i < g.room.npcs.len; i += 1 {
    //     let npc = g.room.npcs.get(i) as *npc.Npc;
    //     npc.update(delta);
    //     g.player.resolve_collision(npc.abs_rect());
    //     npc.render(g.renderer);

    //     if g.debug {
    //         let rect = npc.abs_rect();
    //         g.renderer.draw_rect(&rect);
    //     }
    // }

    // g.player.render(g.renderer);
    // if g.debug {
    //     let rect = g.player.abs_rect();
    //     g.renderer.draw_rect(&rect);
    // }

    return true;
}

def main() {
    if sdl.init(sdl.init_video() | sdl.init_joystick()) < 0 {
        io.printf("Could not init SDL: %s\n", sdl.get_error());
        return;
    }
    defer sdl.quit();

    let flags = sdl.init_png();
    if (sdl.img_init(flags) & flags) != flags {
        io.printf("Coult not init SDL_Image\n");
        return;
    }
    defer sdl.img_quit();

    let display_mode = sdl.get_desktop_display_mode();
    config.set_scale(display_mode.h as u32 / config.pixel_height() / 2);

    let width = config.pixel_width();
    let height = config.pixel_height();

    let window = sdl.create_window(
        "Quasi Pokemon",
        sdl.window_centered(), sdl.window_centered(),
        width, height,
        sdl.window_shown()
    );

    if window == null {
        io.printf("Could not init window: %s\n", sdl.get_error());
        return;
    }
    defer window.destroy();

    let renderer = sdl.create_renderer(window, -1, sdl.present_vsync());
    renderer.set_draw_color(0, 19, 26, 255);
    defer renderer.destroy();

    // let joystick: *sdl.Joystick = null;
    // if sdl.num_joysticks() > 0 && (joystick = sdl.open_joystick(0)) == null {
    //     io.printf("Could not open joystick: %s\n", sdl.get_error());
    //     return;
    // }
    // defer joystick.close();

    let game: Game = undefined;
    game.debug = false;
    game.renderer = renderer;
    game.window = window;

    // game.room = room.create(
    //     renderer,
    //     config.width() / config.tile_size(),
    //     config.height() / config.tile_size()
    // );
    // defer game.room.free();
    // let room = &game.room;

    // game.player = p.load(renderer, width / 2, height / 2);
    // defer game.player.free();
    // game.player.current_animation = &game.player.idle_animation;

    // let cat = npc.load(renderer, npc.Kind.WithDialog, "res/cat.png", 8, 3, 1);
    // cat.data.with_dialog.dialog_text = str.from(
    //     "Meow\n\n\nHey Kid\nyou got some Catnip?"
    // );
    // cat.data.with_dialog.basic.flip = sdl.RendererFlip.Horizontal;
    // room.add_npc(cat);

    // let thot = npc.load(renderer, npc.Kind.WithDialog, "res/thot.png", 12, 14, 5);
    // thot.data.with_dialog.dialog_text = str.from(
    //     "Follow me on twitch, Instagram, Snapchat, Twitter, Youtube\nand onlyfans"
    // );
    // room.add_npc(thot);

    // let goblin = npc.load(renderer, npc.Kind.Enemy, "res/goblin.png", 1, 3, 4);
    // goblin.data.enemy.behaviour = b.follow_player();
    // room.add_npc(goblin);

    // let bed = o.load_simple(renderer, 1, 1, 16, 32, "res/bed.png");
    // room.add_object(bed);
    // let clock = o.load_simple(renderer, 18, 0, 16, 32, "res/clock.png");
    // room.add_object(clock);
    // let table = o.load_simple(renderer, 10, 9, 16, 32, "res/table.png");
    // room.add_object(table);

    // let wall = o.init_trigger(0, 0, config.width(), 16);
    // room.add_object(wall);

    let spec = g.spritesheet_spec(16, 16, "res/girl.png");
    let player_spritesheet: g.SpriteSheet = undefined;
    if !g.load_spritesheet_from_png(renderer, spec, &player_spritesheet) {
        io.printf("Could not load sprite: %s\n", sdl.get_error());
        return;
    }
    defer player_spritesheet.free();

    spec = g.spritesheet_spec(16, 16, "res/cat.png");
    let cat_spritesheet: g.SpriteSheet = undefined;
    if !g.load_spritesheet_from_png(renderer, spec, &cat_spritesheet) {
        io.printf("Could not load sprite: %s\n", sdl.get_error());
        return;
    }
    defer cat_spritesheet.free();

    let player_animations = arena.typed(sizeof g.Animation);
    defer player_animations.free();

    let num_player_animations: usize = 1;
    let player_anim = player_animations.alloc_array(num_player_animations) as *g.Animation;

    let player_idle = g.create_animation(&player_spritesheet, 4, 0);
    defer player_idle.free();
    let player_run_down = g.create_animation(&player_spritesheet, 6, 4);
    defer player_run_down.free();
    let player_run_up = g.create_animation(&player_spritesheet, 6, 10);
    defer player_run_up.free();
    let player_run_horizontal = g.create_animation(&player_spritesheet, 6, 16);
    defer player_run_horizontal.free();

    *(player_anim + 0) = player_idle;
    *(player_anim + 1) = player_run_down;
    *(player_anim + 2) = player_run_up;
    *(player_anim + 3) = player_run_horizontal;

    let player_graphics = g.AnimatedGraphics {
        animations: player_anim,
        num_animations: num_player_animations,
        current_animation: player_anim, // first animation is idle
        flip: sdl.RendererFlip.None
    };

    let initial_pos = math.vec2f(5 as f32, 5 as f32);
    let player_transform = p.Transform { position: initial_pos, scale: config.scale() };
    let player_hitbox = p.hitbox(0, 0, 16, 16);

    let input_marker = Input {};
    let player_movement = p.Movement {
        velocity: math.zero_vec2f(),
        speed: 0.05
    };

    game.ecs = create_ecs();
    defer game.ecs.free();

    let movement_sys = s.movement_system(&game.ecs, &game.input);
    game.ecs.add_system(&movement_sys.s);

    let render_sys = s.animation_render_system(&game.ecs, game.renderer);
    game.ecs.add_system(&render_sys.s);

    let player = game.ecs.create_entity();
    game.ecs.add_component_to_entity(player, ComponentKind.Input, &input_marker as *void);
    game.ecs.add_component_to_entity(player, ComponentKind.AnimatedGraphics, &player_graphics as *void);
    game.ecs.add_component_to_entity(player, ComponentKind.Transform, &player_transform as *void);
    game.ecs.add_component_to_entity(player, ComponentKind.Movement, &player_movement as *void);
    game.ecs.add_component_to_entity(player, ComponentKind.Hitbox, &player_hitbox as *void);

    let cat_anim = g.create_animation(&cat_spritesheet, 8, 0);
    defer cat_anim.free();
    let cat_graphics = g.AnimatedGraphics {
        animations: &cat_anim,
        num_animations: 1,
        current_animation: &cat_anim,
        flip: sdl.RendererFlip.None
    };

    let cat_initial_pos = math.vec2f(100 as f32, 100 as f32);
    let cat_transform = p.Transform { position: cat_initial_pos, scale: config.scale() };
    let cat_hitbox = p.hitbox (0, 0, 16, 16);

    let cat = game.ecs.create_entity();
    game.ecs.add_component_to_entity(cat, ComponentKind.AnimatedGraphics, &cat_graphics as *void);
    game.ecs.add_component_to_entity(cat, ComponentKind.Transform, &cat_transform as *void);
    game.ecs.add_component_to_entity(cat, ComponentKind.Hitbox, &cat_hitbox as *void);

    game.last = sdl.now();
    game.input = i.init_input_map();
    defer game.input.free();

    let running = true;
    while running {
        running = mainloop(&game);
    }

    // emscripten_set_main_loop_arg(&mainloop, &game, -1, 1);
}
